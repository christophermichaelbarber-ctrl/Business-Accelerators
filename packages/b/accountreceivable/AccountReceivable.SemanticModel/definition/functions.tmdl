/// Based on Marco Russo's Account Recievable work, this function creates aged debt based on outstanding involces || date Table ||| date Date Colum ||| ar detail Table |||
function 'ChrisBarber.Finance.AccountRecievable' = ```
		(
			dateTable: anyref EXPR,		
			date_dateColumn: anyref EXPR,	
		
			ardetailTable: anyref EXPR,	
			ardetail_duedateColumn: anyref EXPR,
			ardetail_dueamountColumn: anyref EXPR,
			ardetail_paymentdateColumn: anyref EXPR,
					
			agingrangeTable: anyref EXPR,	
			agingrange_minColumn: anyref EXPR,	
			agingrange_maxColumn: anyref EXPR
		
				
		
		) =>
		VAR MaxDate =
		    max(date_dateColumn)
		VAR Result =
		    CALCULATE (
		        VAR _AgeDetail =
		            ADDCOLUMNS (
		               ardetailTable,
		                "@AgeMin",
		                    VAR _Age =
		                        CONVERT ( MaxDate - ardetail_duedateColumn, INTEGER )
		                    VAR _AgeMin =
		                        SELECTCOLUMNS (
		                            FILTER (
		                                ALLNOBLANKROW (agingrangeTable ),
		                                agingrange_minColumn <= _age
		                                    && (
		                                        agingrange_maxColumn >= _age
		                                            || ISBLANK ( agingrange_maxColumn )
		                                    )
		                            ),
		                           agingrange_minColumn 
		                        )
		                    RETURN
		                        _AgeMin
		            )
		        VAR Result =
		            SUMX (
		                FILTER (
		                    _AgeDetail,
		                    NOT ISBLANK ( [@AgeMin] )
		                        && [@AgeMin] IN VALUES ( agingrange_minColumn  )
		                ),
		                ardetail_dueamountColumn
		            )
		        RETURN
		            Result,
		        ardetail_duedateColumn <= MaxDate,
		        ardetail_paymentdateColumn > MaxDate || ISBLANK ( ardetail_paymentdateColumn),
		        REMOVEFILTERS ( dateTable)
		    )
		RETURN
		    Result
		```
	lineageTag: ad069611-233d-4d29-a7fe-05fcd44afddc

/// Return the value computed in the filtered ABC classes
/// Implement Dynamic ABC Classification pattern from DAX Patterns
/// Article: https://www.daxpatterns.com/abc-classification/
/// You must have a table with the definition of
/// the ABC classes (abcClassTable) with at least two columns,
/// the lower and the upper boundary of each class
/// The first argument is the expression to evaluate for each
/// ite in itemTable, which cardinality is expressed by itemKeyColumn
/// The transactionTable is the table that defines the presence of
/// transactions, typically the table that has the column(s)
/// aggregated in valueExpr
function 'DaxPatterns.AbcClassification.ComputeInAbcClass' = ```
		( 
		    valueExpr : ANYREF EXPR, 
		    transactionsTable : ANYREF EXPR, 
		    itemTable : ANYREF EXPR, 
		    itemKeyColumn : ANYREF EXPR,
		    abcClassTable : ANYREF EXPR,
		    abcLowerBoundaryColumn : ANYREF EXPR,
		    abcUpperBoundaryColumn : ANYREF EXPR
		) =>
		    VAR ProductsInClass = 
		        DaxPatterns.AbcClassification.ItemsInClass( 
		            valueExpr,
		            TransactionsTable, 
		            ItemTable, 
		            ItemKeyColumn, 
		            abcClassTable,
		            abcLowerBoundaryColumn,
		            abcUpperBoundaryColumn 
		        ) 
		    VAR Result =
		        CALCULATE (           
		            valueExpr,
		            KEEPFILTERS ( ProductsInClass )
		        )
		    RETURN Result
		```
	lineageTag: ef2d98e0-e363-4ce5-b04d-a1d492dd0a1a

	annotation DAXLIB_PackageId = DaxPatterns.AbcClassification

	annotation DAXLIB_PackageVersion = 0.1.2

/// Return the items filtered by ABC classes
/// Implement Dynamic ABC Classification pattern from DAX Patterns
/// Article: https://www.daxpatterns.com/abc-classification/
/// You must have a table with the definition of
/// the ABC classes (abcClassTable) with at least two columns,
/// the lower and the upper boundary of each class
/// The first argument is the expression to evaluate for each
/// ite in itemTable, which cardinality is expressed by itemKeyColumn
/// The transactionTable is the table that defines the presence of
/// transactions, typically the table that has the column(s)
/// aggregated in valueExpr
function 'DaxPatterns.AbcClassification.ItemsInClass' = ```
		( 
		    valueExpr : ANYREF EXPR,
		    transactionsTable : ANYREF EXPR, 
		    itemTable : ANYREF EXPR, 
		    itemKeyColumn : ANYREF EXPR, 
		    abcClassTable : ANYREF EXPR,
		    abcLowerBoundaryColumn : ANYREF EXPR,
		    abcUpperBoundaryColumn : ANYREF EXPR
		) => 
		    VAR TransactionsByItem = 	
		        CALCULATETABLE (
		            ADDCOLUMNS (
		                SUMMARIZE ( transactionsTable, itemKeyColumn ),
		                "@Value", CALCULATE ( valueExpr )
		            ),
		            ALLSELECTED ( itemTable )
		        )
		    VAR AllItemsValue =
		        SUMX ( 
		            transactionsByItem,
		            [@Value]
		        )
		    VAR CumulatedPctByItemTable = 
		        ADDCOLUMNS ( 
		            transactionsByItem, 
		            "@CumulatedPct", 
		                VAR CumulatedValue = 
		                    SUMX ( 
		                        WINDOW ( 
		                            1, ABS, 
		                            0, REL, 
		                            transactionsByItem, 
		                            ORDERBY ( [@Value], DESC ) 
		                        ), 
		                        [@Value] 
		                    )
		                VAR Perc = 
		                    DIVIDE (
		                        CumulatedValue,
		                        AllItemsValue
		                    )
		                RETURN
		                    MIN ( Perc, 1 ) -- Avoid >100% in case of rounding issues
		        )
		    
		    VAR Result =
		        FILTER (
		            CROSSJOIN (
		                CumulatedPctByItemTable,
		                abcClassTable
		            ),
		            AND (
		                [@CumulatedPct] > abcLowerBoundaryColumn,
		                [@CumulatedPct] <= abcUpperBoundaryColumn
		            )
		        )
		    RETURN Result
		```
	lineageTag: 253a7e69-6ae8-4a85-9cf4-a310c7328be3

	annotation DAXLIB_PackageId = DaxPatterns.AbcClassification

	annotation DAXLIB_PackageVersion = 0.1.2

